<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Set up a model formula for use in 'brms'</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for brmsformula {brms}"><tr><td>brmsformula {brms}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Set up a model formula for use in <span class="pkg">brms</span></h2>

<h3>Description</h3>

<p>Set up a model formula for use in the <span class="pkg">brms</span> package
allowing to define (potentially non-linear) additive multilevel 
models for all parameters of the assumed response distribution.
</p>


<h3>Usage</h3>

<pre>
brmsformula(formula, ..., flist = NULL, family = NULL, autocor = NULL,
  nl = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>
<p>An object of class <code>formula</code> 
(or one that can be coerced to that class): 
a symbolic description of the model to be fitted. 
The details of model specification are given in 'Details'.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Additional <code>formula</code> objects to specify 
predictors of non-linear and distributional parameters. 
Formulas can either be named directly or contain
names on their left-hand side. 
The following are distributional parameters of specific families
(all other parameters are treated as non-linear parameters):
<code>sigma</code> (residual standard deviation or scale of
the <code>gaussian</code>, <code>student</code>, <code>skew_normal</code>, 
<code>lognormal</code> <code>exgaussian</code>, and <code>asym_laplace</code> families);
<code>shape</code> (shape parameter of the <code>Gamma</code>,
<code>weibull</code>, <code>negbinomial</code>, and related
zero-inflated / hurdle families); <code>nu</code> (degrees of freedom 
parameter of the <code>student</code> and <code>frechet</code> families);
<code>phi</code> (precision parameter of the <code>beta</code> 
and <code>zero_inflated_beta</code> families);
<code>kappa</code> (precision parameter of the <code>von_mises</code> family);
<code>beta</code> (mean parameter of the exponential component
of the <code>exgaussian</code> family);
<code>quantile</code> (quantile parameter of the <code>asym_laplace</code> family);
<code>zi</code> (zero-inflation probability); 
<code>hu</code> (hurdle probability);
<code>zoi</code> (zero-one-inflation probability);
<code>coi</code> (conditional one-inflation probability);
<code>disc</code> (discrimination) for ordinal models;
<code>bs</code>, <code>ndt</code>, and <code>bias</code> (boundary separation,
non-decision time, and initial bias of the <code>wiener</code>
diffusion model).
By default, distributional parameters are modeled 
on the log scale if they can be positive only or on the 
logit scale if the can only be within the unit interval.
See 'Details' for more explanation.</p>
</td></tr>
<tr valign="top"><td><code>flist</code></td>
<td>
<p>Optional list of formulas, which are treated in the 
same way as formulas passed via the <code>...</code> argument.</p>
</td></tr>
<tr valign="top"><td><code>family</code></td>
<td>
<p>Same argument as in <code><a href="brm.html">brm</a></code>.
If <code>family</code> is specified in <code>brmsformula</code>, it will 
overwrite the value specified in <code><a href="brm.html">brm</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>autocor</code></td>
<td>
<p>Same argument as in <code><a href="brm.html">brm</a></code>.
If <code>autocor</code> is specified in <code>brmsformula</code>, it will 
overwrite the value specified in <code><a href="brm.html">brm</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>nl</code></td>
<td>
<p>Logical; Indicates whether <code>formula</code> should be
treated as specifying a non-linear model. By default, <code>formula</code> 
is treated as an ordinary linear model formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>General formula structure</b>
</p>
<p>The <code>formula</code> argument accepts formulas of the following syntax:
</p>
<p><code>response | aterms ~ pterms + (gterms | group)</code> 
</p>
<p>The <code>pterms</code> part contains effects that are assumed to be the 
same across observations. We call them 'population-level' effects
or (adopting frequentist vocabulary) 'fixed' effects. The optional
<code>gterms</code> part may contain effects that are assumed to vary
across grouping variables specified in <code>group</code>. We
call them 'group-level' effects or (adopting frequentist 
vocabulary) 'random' effects, although the latter name is misleading
in a Bayesian context. For more details type 
<code>vignette("brms_overview")</code> and <code>vignette("brms_multilevel")</code>. 
</p>
<p><b>Group-level terms</b>
</p>
<p>Multiple grouping factors each with multiple group-level effects 
are possible. (Of course we can also run models without any
group-level effects.) 
Instead of <code>|</code> you may use <code>||</code> in grouping terms
to prevent correlations from being modeled. 
Alternatively, it is possible to model different group-level terms of 
the same grouping factor as correlated (even across different formulas,
e.g., in non-linear models) by using <code>|&lt;ID&gt;|</code> instead of <code>|</code>.
All group-level terms sharing the same ID will be modeled as correlated.
If, for instance, one specifies the terms <code>(1+x|2|g)</code> and 
<code>(1+z|2|g)</code> somewhere in the formulas passed to <code>brmsformula</code>,
correlations between the corresponding group-level effects 
will be estimated.
</p>
<p>If levels of the grouping factor belong to different sub-populations,
it may be reasonable to assume a different covariance matrix for each 
of the sub-populations. For instance, the variation within the
treatment group and within the control group in a randomized control
trial might differ. Suppose that <code>y</code> is the outcome, and
<code>x</code> is the factor indicating the treatment and control group. 
Then, we could estimate different hyper-parameters of the varying
effects (in this case a varying intercept) for treatment and control
group via <code>y ~ x + (1 | gr(subject, by = x))</code>.
</p>
<p>You can specify multi-membership terms using the <code><a href="mm.html">mm</a></code> 
function. For instance, a multi-membership term with two members 
could be <code>(1 | mm(g1, g2))</code>, where <code>g1</code> and <code>g2</code> 
specify the first and second member, respectively. Moreover,
if a covariate <code>x</code> varies across the levels of the grouping-factors
<code>g1</code> and <code>g2</code>, we can save the respective covariate values
in the variables <code>x1</code> and <code>x2</code> and then model the varying
effect as <code>(1 + mmc(x1, x2) | mm(g1, g2))</code>.
</p>
<p><b>Special predictor terms</b>
</p>
<p>Smoothing terms can modeled using the <code><a href="s.html">s</a></code>
and <code><a href="s.html">t2</a></code> functions in the <code>pterms</code> part 
of the model formula. This allows to fit generalized additive mixed
models (GAMMs) with <span class="pkg">brms</span>. The implementation is similar to that 
used in the <span class="pkg">gamm4</span> package. For more details on this model class 
see <code><a href="../../mgcv/html/gam.html">gam</a></code> and <code><a href="../../mgcv/html/gamm.html">gamm</a></code>.
</p>
<p>Gaussian process terms can be fitted using the <code><a href="gp.html">gp</a></code>
function in the <code>pterms</code> part of the model formula. Similar to
smooth terms, Gaussian processes can be used to model complex non-linear
relationships, for instance temporal or spatial autocorrelation. 
However, they are computationally demanding and are thus not recommended 
for very large datasets.
</p>
<p>The <code>pterms</code> and <code>gterms</code> parts may contain four non-standard
effect types namely monotonic, measurement error, missing value, and 
category specific effects, which can be specified using terms of the 
form <code>mo(predictor)</code>, <code>me(predictor, sd_predictor)</code>, 
<code>mi(predictor)</code>, and <code>cs(&lt;predictors&gt;)</code>, respectively. 
Category specific effects can only be estimated in
ordinal models and are explained in more detail in the package's 
main vignette (type <code>vignette("brms_overview")</code>). 
The other thee effect types are explained in the following.
</p>
<p>A monotonic predictor must either be integer valued or an ordered factor, 
which is the first difference to an ordinary continuous predictor. 
More importantly, predictor categories (or integers) are not assumed to be 
equidistant with respect to their effect on the response variable. 
Instead, the distance between adjacent predictor categories (or integers) 
is estimated from the data and may vary across categories. 
This is realized by parameterizing as follows: 
One parameter takes care of the direction and size of the effect similar 
to an ordinary regression parameter, while an additional parameter vector 
estimates the normalized distances between consecutive predictor categories.     
A main application of monotonic effects are ordinal predictors that
can this way be modeled without (falsely) treating them as continuous
or as unordered categorical predictors. For more details and examples
see <code>vignette("brms_monotonic")</code>.
</p>
<p>Quite often, predictors are measured and as such naturally contain 
measurement error. Although most researchers are well aware of this problem,
measurement error in predictors is ignored in most
regression analyses, possibly because only few packages allow
for modeling it. Notably, measurement error can be handled in 
structural equation models, but many more general regression models
(such as those featured by <span class="pkg">brms</span>) cannot be transferred 
to the SEM framework. In <span class="pkg">brms</span>, effects of noise-free predictors 
can be modeled using the <code>me</code> (for 'measurement error') function.
If, say, <code>y</code> is the response variable and 
<code>x</code> is a measured predictor with known measurement error
<code>sdx</code>, we can simply include it on the right-hand side of the
model formula via <code>y ~ me(x, sdx)</code>. 
This can easily be extended to more general formulas. 
If <code>x2</code> is another measured predictor with corresponding error
<code>sdx2</code> and <code>z</code> is a predictor without error
(e.g., an experimental setting), we can model all main effects 
and interactions of the three predictors in the well known manner: 
<code>y ~ me(x, sdx) * me(x2, sdx2) * z</code>. In future version of <span class="pkg">brms</span>,
a vignette will be added to explain more details about these
so called 'error-in-variables' models and provide real world examples.
</p>
<p>When a variable contains missing values, the corresponding rows will
be excluded from the data by default (row-wise exclusion). However,
quite often we want to keep these rows and instead estimate the missing values.
There are two approaches for this: (a) Impute missing values before
the model fitting for instance via multiple imputation (see
<code><a href="brm_multiple.html">brm_multiple</a></code> for a way to handle multiple imputed datasets).
(b) Impute missing values on the fly during model fitting. The latter
approach is explained in the following. Using a variable with missing 
values as predictors requires two things, First, we need to specify that 
the predictor contains missings that should to be imputed. 
If, say, <code>y</code> is the primary response, <code>x</code> is a 
predictor with missings and <code>z</code> is a predictor without missings, 
we go for <code>y ~ mi(x) + z</code>. Second, we need to model <code>x</code> 
as an additional response with corresponding predictors and the 
addition term <code>mi()</code>. In our example, we could write
<code>x | mi() ~ z</code>. See <code><a href="mi.html">mi</a></code> for examples with real data.
</p>
<p><b>Additional response information</b>
</p>
<p>Another special of the <span class="pkg">brms</span> formula syntax is the optional 
<code>aterms</code> part, which may contain multiple terms of the form 
<code>fun(&lt;variable&gt;)</code> separated by <code>+</code> each providing special 
information on the response variable. <code>fun</code> can be replaced with 
either <code>se</code>, <code>weights</code>, <code>cens</code>, <code>trunc</code>, 
<code>trials</code>, <code>cat</code>, or <code>dec</code>. Their meanings are explained below.
(see also <code><a href="addition-terms.html">addition-terms</a></code>). 
</p>
<p>For families <code>gaussian</code>, <code>student</code> and <code>skew_normal</code>, it is 
possible to specify standard errors of the observations, thus allowing 
to perform meta-analysis. Suppose that the variable <code>yi</code> contains 
the effect sizes from the studies and <code>sei</code> the corresponding 
standard errors. Then, fixed and random effects meta-analyses can 
be conducted using the formulas <code>yi | se(sei) ~ 1</code> and 
<code>yi | se(sei) ~ 1 + (1|study)</code>, respectively, where 
<code>study</code> is a variable uniquely identifying every study.
If desired, meta-regression can be performed via 
<code>yi | se(sei) ~ 1 + mod1 + mod2 + (1|study)</code> 
or <br /> <code>yi | se(sei) ~ 1 + mod1 + mod2 + (1 + mod1 + mod2|study)</code>, 
where <code>mod1</code> and <code>mod2</code> represent moderator variables. 
By default, the standard errors replace the parameter <code>sigma</code>.
To model <code>sigma</code> in addition to the known standard errors,
set argument <code>sigma</code> in function <code>se</code> to <code>TRUE</code>, 
for instance, <code>yi | se(sei, sigma = TRUE) ~ 1</code>.
</p>
<p>For all families, weighted regression may be performed using
<code>weights</code> in the <code>aterms</code> part. Internally, this is 
implemented by multiplying the log-posterior values of each 
observation by their corresponding weights.
Suppose that variable <code>wei</code> contains the weights 
and that <code>yi</code> is the response variable. 
Then, formula <code>yi | weights(wei) ~ predictors</code> 
implements a weighted regression. 
</p>
<p>With the exception of categorical, ordinal, and mixture families, 
left, right, and interval censoring can be modeled through 
<code>y | cens(censored) ~ predictors</code>. The censoring variable 
(named <code>censored</code> in this example) should contain the values 
<code>'left'</code>, <code>'none'</code>, <code>'right'</code>, and <code>'interval'</code> 
(or equivalently <code>-1</code>, <code>0</code>, <code>1</code>, and <code>2</code>) to indicate that 
the corresponding observation is left censored, not censored, right censored,
or interval censored. For interval censored data, a second variable
(let's call it <code>y2</code>) has to be passed to <code>cens</code>. In this case, 
the formula has the structure <code>y | cens(censored, y2) ~ predictors</code>. 
While the lower bounds are given in <code>y</code>, the upper bounds are given 
in <code>y2</code> for interval censored data. Intervals are assumed to be open 
on the left and closed on the right: <code>(y, y2]</code>.
</p>
<p>With the exception of categorical, ordinal, and mixture families, 
the response distribution can be truncated using the <code>trunc</code> 
function in the addition part. If the response variable is truncated 
between, say, 0 and 100, we can specify this via
<code>yi | trunc(lb = 0, ub = 100) ~ predictors</code>. 
Instead of numbers, variables in the data set can also be passed allowing 
for varying truncation points across observations. Defining only one of 
the two arguments in <code>trunc</code> leads to one-sided truncation.
</p>
<p>For all continuous families, missing values in the responses can be imputed 
within Stan by using the addition term <code>mi</code>. This is mostly 
useful in combination with <code>mi</code> predictor terms as explained 
above under 'Special predictor terms'.
</p>
<p>For families <code>binomial</code> and <code>zero_inflated_binomial</code>, 
addition should contain a variable indicating the number of trials 
underlying each observation. In <code>lme4</code> syntax, we may write for instance 
<code>cbind(success, n - success)</code>, which is equivalent
to <code>success | trials(n)</code> in <span class="pkg">brms</span> syntax. If the number of trials
is constant across all observations, say <code>10</code>, 
we may also write <code>success | trials(10)</code>. 
</p>
<p>For all ordinal families, <code>aterms</code> may contain a term 
<code>cat(number)</code> to specify the number categories (e.g, <code>cat(7)</code>). 
If not given, the number of categories is calculated from the data.
</p>
<p>In Wiener diffusion models (family <code>wiener</code>) the addition term
<code>dec</code> is mandatory to specify the (vector of) binary decisions 
corresponding to the reaction times. Non-zero values will be treated
as a response on the upper boundary of the diffusion process and zeros
will be treated as a response on the lower boundary. Alternatively,
the variable passed to <code>dec</code> might also be a character vector 
consisting of <code>'lower'</code> and <code>'upper'</code>.
</p>
<p>Multiple addition terms may be specified at the same time using 
the <code>+</code> operator, for instance <br />
<code>formula = yi | se(sei) + cens(censored) ~ 1</code> 
for a censored meta-analytic model. 
</p>
<p>The addition argument <code>disp</code> (short for dispersion) 
has been removed in version 2.0. You may instead use the 
distributional regression approach by specifying
<code>sigma ~ 1 + offset(log(xdisp))</code> or
<code>shape ~ 1 + offset(log(xdisp))</code>, where <code>xdisp</code> is
the variable being previously passed to <code>disp</code>.
</p>
<p><b>Parameterization of the population-level intercept</b>
</p>
<p>The population-level intercept (if incorporated) is estimated separately 
and not as part of population-level parameter vector <code>b</code>. 
As a result, priors on the intercept also have to be specified separately.
Furthermore, to increase sampling efficiency, the population-level 
design matrix <code>X</code> is centered around its column means 
<code>X_means</code> if the intercept is incorporated. 
This leads to a temporary bias in the intercept equal to 
<code>&lt;X_means, b&gt;</code>, where <code>&lt;,&gt;</code> is the scalar product. 
The bias is corrected after fitting the model, but be aware 
that you are effectively defining a prior on the intercept 
of the centered design matrix not on the real intercept.
For more details on setting priors on population-level intercepts,
see <code><a href="set_prior.html">set_prior</a></code>.
</p>
<p>This behavior can be avoided by using the reserved 
(and internally generated) variable <code>intercept</code>. 
Instead of <code>y ~ x</code>, you may write
<code>y ~ 0 + intercept + x</code>. This way, priors can be
defined on the real intercept, directly. In addition,
the intercept is just treated as an ordinary population-level effect
and thus priors defined on <code>b</code> will also apply to it. 
Note that this parameterization may be less efficient
than the default parameterization discussed above.  
</p>
<p><b>Formula syntax for non-linear models</b>
</p>
<p>In <span class="pkg">brms</span>, it is possible to specify non-linear models 
of arbitrary complexity.
The non-linear model can just be specified within the <code>formula</code>
argument. Suppose, that we want to predict the response <code>y</code>
through the predictor <code>x</code>, where <code>x</code> is linked to <code>y</code>
through <code>y = alpha - beta * lambda^x</code>, with parameters
<code>alpha</code>, <code>beta</code>, and <code>lambda</code>. This is certainly a
non-linear model being defined via
<code>formula = y ~ alpha - beta * lambda^x</code> (addition arguments 
can be added in the same way as for ordinary formulas).
To tell <code>brms</code> that this is a non-linear model, 
we set argument <code>nl</code> to <code>TRUE</code>.
Now we have to specify a model for each of the non-linear parameters. 
Let's say we just want to estimate those three parameters
with no further covariates or random effects. Then we can pass
<code>alpha + beta + lambda ~ 1</code> or equivalently
(and more flexible) <code>alpha ~ 1, beta ~ 1, lambda ~ 1</code> 
to the <code>...</code> argument.
This can, of course, be extended. If we have another predictor <code>z</code> and 
observations nested within the grouping factor <code>g</code>, we may write for 
instance <code>alpha ~ 1, beta ~ 1 + z + (1|g), lambda ~ 1</code>.
The formula syntax described above applies here as well.
In this example, we are using <code>z</code> and <code>g</code> only for the 
prediction of <code>beta</code>, but we might also use them for the other
non-linear parameters (provided that the resulting model is still 
scientifically reasonable). 
</p>
<p>Non-linear models may not be uniquely identified and / or show bad convergence.
For this reason it is mandatory to specify priors on the non-linear parameters.
For instructions on how to do that, see <code><a href="set_prior.html">set_prior</a></code>.
For some examples of non-linear models, see <code>vignette("brms_nonlinear")</code>.
</p>
<p><b>Formula syntax for predicting distributional parameters</b>
</p>
<p>It is also possible to predict parameters of the response
distribution such as the residual standard deviation <code>sigma</code> 
in gaussian models or the hurdle probability <code>hu</code> in hurdle models. 
The syntax closely resembles that of a non-linear 
parameter, for instance <code>sigma ~ x + s(z) + (1+x|g)</code>. 
For some examples of distributional models, see <code>vignette("brms_distreg")</code>.
</p>
<p>Alternatively, one may fix distributional parameters to certain values.
However, this is mainly useful when models become too 
complicated and otherwise have convergence issues. 
We thus suggest to be generally careful when making use of this option. 
The <code>quantile</code> parameter of the <code>asym_laplace</code> distribution
is a good example where it is useful. By fixing <code>quantile</code>, 
one can perform quantile regression for the specified quantile. 
For instance, <code>quantile = 0.25</code> allows predicting the 25%-quantile.
Furthermore, the <code>bias</code> parameter in drift-diffusion models, 
is assumed to be <code>0.5</code> (i.e. no bias) in many applications. 
To achieve this, simply write <code>bias = 0.5</code>. 
Other possible applications are the Cauchy distribution as a 
special case of the Student-t distribution with 
<code>nu = 1</code>, or the geometric distribution as a special case of
the negative binomial distribution with <code>shape = 1</code>.
Furthermore, the parameter <code>disc</code> ('discrimination') in ordinal 
models is fixed to <code>1</code> by default and not estimated,
but may be modeled as any other distributional parameter if desired
(see examples). For reasons of identification, <code>'disc'</code>
can only be positive, which is achieved by applying the log-link.
</p>
<p>In categorical models, distributional parameters do not have
fixed names. Instead, they are named after the response categories 
(excluding the first one, which serves as the reference category),
with the prefix <code>'mu'</code>. If, for instance, categories are named 
<code>cat1</code>, <code>cat2</code>, and <code>cat3</code>, the distributional parameters
will be named <code>mucat2</code> and <code>mucat3</code>.
</p>
<p>Some distributional parameters currently supported by <code>brmsformula</code>
have to be positive (a negative standard deviation or precision parameter 
does not make any sense) or are bounded between 0 and 1 (for zero-inflated / 
hurdle probabilities, quantiles, or the initial bias parameter of 
drift-diffusion models). 
However, linear predictors can be positive or negative, and thus the log link 
(for positive parameters) or logit link (for probability parameters) are used 
by default to ensure that distributional parameters are within their valid intervals.
This implies that, by default, effects for such distributional parameters are 
estimated on the log / logit scale and one has to apply the inverse link 
function to get to the effects on the original scale.
Alternatively, it is possible to use the identity link to predict parameters
on their original scale, directly. However, this is much more likely to lead 
to problems in the model fitting, if the parameter actually has a restricted range.
</p>
<p>See also <code><a href="brmsfamily.html">brmsfamily</a></code> for an overview of valid link functions.
</p>
<p><b>Formula syntax for mixture models</b>
</p>
<p>The specification of mixture models closely resembles that 
of non-mixture models. If not specified otherwise (see below), 
all mean parameters of the mixture components are predicted
using the right-hand side of <code>formula</code>. All types of predictor
terms allowed in non-mixture models are allowed in mixture models
as well.
</p>
<p>distributional parameters of mixture distributions have the same 
name as those of the corresponding ordinary distributions, but with 
a number at the end to indicate the mixture component. For instance, if
you use family <code>mixture(gaussian, gaussian)</code>, the distributional
parameters are <code>sigma1</code> and <code>sigma2</code>.
distributional parameters of the same class can be fixed to the same value. 
For the above example, we could write <code>sigma2 = "sigma1"</code> to make
sure that both components have the same residual standard deviation,
which is in turn estimated from the data.
</p>
<p>In addition, there are two types of special distributional parameters.
The first are named <code>mu&lt;ID&gt;</code>, that allow for modeling different 
predictors for the mean parameters of different mixture components. 
For instance, if you want to predict the mean of the first component 
using predictor <code>x</code> and the mean of the second component using 
predictor <code>z</code>, you can write <code>mu1 ~ x</code> as well as <code>mu2 ~ z</code>. 
The second are named <code>theta&lt;ID&gt;</code>, which constitute the mixing 
proportions. If the mixing proportions are fixed to certain values, 
they are internally normalized to form a probability vector.
If one seeks to predict the mixing proportions, all but 
one of the them has to be predicted, while the remaining one is used
as the reference category to identify the model. The <code>softmax</code> 
function is applied on the linear predictor terms to form a 
probability vector.
</p>
<p>For more information on mixture models, see
the documentation of <code><a href="mixture.html">mixture</a></code>.
</p>
<p><b>Formula syntax for multivariate models</b>
</p>
<p>Multivariate models may be specified using <code>cbind</code> notation
or with help of the <code><a href="mvbrmsformula.html">mvbf</a></code> function.
Suppose that <code>y1</code> and <code>y2</code> are response variables 
and <code>x</code> is a predictor. Then <code>cbind(y1, y2) ~ x</code> 
specifies a multivariate model,
The effects of all terms specified at the RHS of the formula 
are assumed to vary across response variables. 
For instance, two parameters will be estimated for <code>x</code>, 
one for the effect on <code>y1</code> and another for the effect on <code>y2</code>.
This is also true for group-level effects. When writing, for instance,
<code>cbind(y1, y2) ~ x + (1+x|g)</code>, group-level effects will be
estimated separately for each response. To model these effects
as correlated across responses, use the ID syntax (see above).
For the present example, this would look as follows:
<code>cbind(y1, y2) ~ x + (1+x|2|g)</code>. Of course, you could also use
any value other than <code>2</code> as ID.
</p>
<p>It is also possible to specify different formulas for different responses.
If, for instance, <code>y1</code> should be predicted by <code>x</code> and <code>y2</code>
should be predicted by <code>z</code>, we could write <code>mvbf(y1 ~ x, y2 ~ z)</code>.
Alternatively, multiple <code>brmsformula</code> objects can be added to
specify a joint multivariate model (see 'Examples').
</p>


<h3>Value</h3>

<p>An object of class <code>brmsformula</code>, which
is essentially a <code>list</code> containing all model
formulas as well as some additional information.
</p>


<h3>See Also</h3>

<p><code><a href="mvbrmsformula.html">mvbrmsformula</a></code>, <code><a href="brmsformula-helpers.html">brmsformula-helpers</a></code>
</p>


<h3>Examples</h3>

<pre>
# multilevel model with smoothing terms
brmsformula(y ~ x1*x2 + s(z) + (1+x1|1) + (1|g2))

# additionally predict 'sigma'
brmsformula(y ~ x1*x2 + s(z) + (1+x1|1) + (1|g2), 
            sigma ~ x1 + (1|g2))
            
# use the shorter alias 'bf'
(formula1 &lt;- brmsformula(y ~ x + (x|g)))
(formula2 &lt;- bf(y ~ x + (x|g)))
# will be TRUE
identical(formula1, formula2)

# incorporate censoring
bf(y | cens(censor_variable) ~ predictors)

# define a simple non-linear model
bf(y ~ a1 - a2^x, a1 + a2 ~ 1, nl = TRUE)

# predict a1 and a2 differently
bf(y ~ a1 - a2^x, a1 ~ 1, a2 ~ x + (x|g), nl = TRUE)

# correlated group-level effects across parameters
bf(y ~ a1 - a2^x, a1 ~ 1 + (1|2|g), a2 ~ x + (x|2|g), nl = TRUE)

# define a multivariate model
bf(cbind(y1, y2) ~ x * z + (1|g))

# define a zero-inflated model 
# also predicting the zero-inflation part
bf(y ~ x * z + (1+x|ID1|g), zi ~ x + (1|ID1|g))

# specify a predictor as monotonic
bf(y ~ mo(x) + more_predictors)

# for ordinal models only
# specify a predictor as category specific
bf(y ~ cs(x) + more_predictors)
# add a category specific group-level intercept
bf(y ~ cs(x) + (cs(1)|g))
# specify parameter 'disc'
bf(y ~ person + item, disc ~ item)

# specify variables containing measurement error
bf(y ~ me(x, sdx))

# specify predictors on all parameters of the wiener diffusion model
# the main formula models the drift rate 'delta'
bf(rt | dec(decision) ~ x, bs ~ x, ndt ~ x, bias ~ x)

# fix the bias parameter to 0.5
bf(rt | dec(decision) ~ x, bias = 0.5)

# specify different predictors for different mixture components
mix &lt;- mixture(gaussian, gaussian)
bf(y ~ 1, mu1 ~ x, mu2 ~ z, family = mix)

# fix both residual standard deviations to the same value
bf(y ~ x, sigma2 = "sigma1", family = mix)

# use the '+' operator to specify models
bf(y ~ 1) + 
  nlf(sigma ~ a * exp(b * x), a ~ x) + 
  lf(b ~ z + (1|g), dpar = "sigma") +
  gaussian()
  
# specify a multivariate model using the '+' operator
bf(y1 ~ x + (1|g)) + 
  gaussian() + cor_ar(~1|g) +
  bf(y2 ~ z) + poisson()
  
# model missing values in predictors
bf(bmi ~ age * mi(chl)) +
  bf(chl | mi() ~ age) + 
  set_rescor(FALSE)

</pre>

<hr /><div style="text-align: center;">[Package <em>brms</em> version 2.3.0 <a href="00Index.html">Index</a>]</div>
</body></html>
