---
title: "SSVEP reward - behavioral results"
author: 'Ivan Grahek & Antonio Schettino'
date: '`r Sys.Date()`'
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_float: yes
    theme: default 
---


## About the code

Experiment: FSAReward (Ivan Grahek*, Antonio Schettino*, Gilles Pourtois, Ernst Koster, & SÃ¸ren Andersen) (*: co-first authors)
Code written by: Ivan Grahek & Antonio Schettino (2016-2018)
Description: Code for the analysis of behavioral data for Experiment 1 of the SSVEP - reward project.  

_This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>._


\newpage

## Accuracy data
```{r, warning=FALSE, message=FALSE}
# Clear environemnt and import data------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

# clear the environment
rm(list=ls()) 
# clear the console
cat("\014") 
#load packages and install them if they're not installed
if (!require("pacman")) install.packages("pacman")
pacman::p_load(plyr,Rmisc,yarrr,BayesFactor,reshape2,brms, broom, tidyverse, brmstools, BEST)
# set seed
set.seed(42) 
# set directory
setwd("C:/Users/igrahek/Documents/Studies/SSVEP Reward - Soren & Antonio/Experiment 1/SSVEP and reward/")
# import data
data.raw = read.csv(file="C:/Users/igrahek/Documents/Studies/SSVEP Reward - Soren & Antonio/Experiment 1/SSVEP and reward/data/Data_behavior_exp1_48pps.csv",header=TRUE,na.strings="NaN") 

# Prepare the dataset------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Adding and renaming variables 
# rename EventType variable
names(data.raw)[names(data.raw) == "EventType"] = "MovedDots" 
# add a variable with the name of the attended color instead of a numbers
data.raw$AttendedColor = ifelse(data.raw$AttendedColor==1,"red","blue")
# add a variable saying which color was linked with High_Rew (even numbers - blue was High_Rew)
data.raw$RewardedColor = ifelse(data.raw$ParticipantNo%%2==0,"blue","red") 
# add a variable with the name of the moved color instead of a numbers
data.raw$MovedDots = ifelse(data.raw$MovedDots==1,"red","blue") 
# split experimental phases into 6 isntead of 3 phases (trial 0-200: Bsln; trial 201-400: Acq; trial 401-600: Ext)
#data.raw$ExpPhase = cut(data.raw$Trial,breaks=c(0,100,200,300,400,500,600),labels=c("Bsln1","Bsln2","Acq1","Acq2","Ext1","Ext2")) 
# split experimental phases into 3 phases (trial 0-200: Bsln; trial 201-400: Acq; trial 401-600: Ext)
data.raw$ExpPhase = cut(data.raw$Trial,breaks=c(0,200,400,600),labels=c("Bsln","Acq","Ext")) # trial 0-200: Bsln; trial 201-400: Acq; trial 401-600: Ext

### Convert variables to be used in analyses into factors
data.raw[c("ParticipantNo", "AttendedColor","RewardedColor", "MovedDots", "ExpPhase" )] = 
  lapply(data.raw[c("ParticipantNo", "AttendedColor","RewardedColor", "MovedDots", "ExpPhase" )], factor)

### Create variables needed for the accuracy analyses
# count hits, false alarms, misses, correct rejections, and RT separately for each participant (their calculation is done in Matlab: see DataProcessing.m)
data.final = ddply(data.raw,.(ParticipantNo,ExpPhase,AttendedColor,RewardedColor,MovedDots),summarize,
                  numtrials=length(which(Response!=99)), # number of trials per condition (anything that is not 99 or any other number that we're not using)
                  Hits=length(which(Response==1)), # hits: attended color moved, correct response
                  FAs=length(which(Response==2)), # false alarms: attended color did not move, (wrong) response
                  Misses=length(which(Response==0)), # misses: attended color moved, no response
                  CRs=length(which(Response==3)), # correct rejections: attended color did not move, no response
                  mean.RT=mean(RT,na.rm=TRUE)) # mean RT per condition


################################################################## Calculate accuracy and RTs per condition ###############################################################################################################################################################################################################

# Prepare the data------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Calculate Hits and False alarms
# Hits are calculated for each participant in each condition on trials when they are attending the color that moved. 
# False alarms are  calculated for each participant in each condition on trials when they are attending the color that didn't move (the unattended color moved, but they responded)  
# Here we create the same number of hits & fas for each of the two conditions (moved attended or not)
data.final = ddply(data.final, .(ParticipantNo,ExpPhase,AttendedColor), transform, 
                 Hits = Hits[MovedDots==AttendedColor],
                 FAs = FAs[MovedDots!=AttendedColor])

# Keep only trials on which the attended color moved (we can do behavioral analysis only on those)
data.final = subset(data.final,MovedDots==AttendedColor)

### Calculate d'
# use loglinear transformation: add 0.5 to Hits, FAs, Misses, and CRs (Hautus, 1995, Behavior Research Methods, Instruments, & Computers),
# which is preferred over the 1/2N rule (Macmillan & Kaplan, 1985, Psychological Bulletin) because it results in less biased estimates of d'.
data.final =  ddply(data.final,.(ParticipantNo,ExpPhase,RewardedColor,AttendedColor,numtrials),summarize,
                      tot.Hits=Hits+.5, # hits
                      tot.FAs=FAs+.5, # false alarms
                      tot.Misses=(numtrials-tot.Hits)+.5, # misses
                      tot.CRs=(numtrials-tot.FAs)+.5, # correct rejections
                      Hit.Rate=tot.Hits/(tot.Hits+tot.Misses), # hit rate
                      FA.Rate=tot.FAs/(tot.FAs+tot.CRs), # false alarm rate
                      dprime=qnorm(Hit.Rate)-qnorm(FA.Rate),
                      Hits.RTs=mean(mean.RT,na.rm=TRUE)) # mean RTs
                      

# Handle outliers------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Determine outliers and cut them
# outliers based on hit rate at any condition
#crit = .6 # minimum 60% hit rate in any condition .6
# select participants below the criterion
#criterion = subset(ddply(data.final,.(ParticipantNo),summarize,mean.Hit.Rate=mean(Hit.Rate)),mean.Hit.Rate<crit)$Participant # minimum 60% hit rate across all conditions

#criterion = subset(data.final,data.final$Hit.Rate<.3)$Participant # minimum 60% hit rate across all conditions

# eliminate ouotliers from data frame
#data.final = data.final[!data.final$ParticipantNo %in% unique(criterion),] 

# Create the final dataframe for accuracy and RTs ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### Create a final dataframe for accuracy and RTs analyses
# add a new variable specifying whether the participant is attending the high or Low_Rewed color
data.final$Condition = ifelse(data.final$RewardedColor==data.final$AttendedColor,"High_Rew","Low_Rew")
# make this variable a factor for further analyses
data.final$Condition = factor(data.final$Condition)

```
### Plot

```{r, warning=FALSE, message=FALSE}
# # Plot Hit rates------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
# 
  # Pirate plot
  pirateplot(formula=Hit.Rate~ExpPhase+Condition, # dependent~independent variables
             data=data.final, # data frame
             main="Hit rates", # main title
             xlim=NULL, # x-axis: limits
             xlab="", # x-axis: label
             ylim=c(0,1), # y-axis: limits
             ylab="Hit Rate", # y-axis: label
             inf.method="hdi", # type of inference: 95% Bayesian Highest Density Intervals
             hdi.iter=5000, # number of iterations for estimation of HDI
             inf.within=ParticipantNo, # ID variable
             theme=0, # preset theme (0: use your own)
             # theme settings
             # pal="xman", # color palette [see piratepal(palette="all")]
             point.col="black", # points: color
             point.o=.3, # points: opacity (0-1)
             avg.line.col="black", # average line: color
             avg.line.lwd=2, # average line: line width
             avg.line.o=1, # average line: opacity (0-1)
             bar.b.col=NULL, # bars, border: color
             bar.lwd=0, # bars, border: line width
             bar.b.o=0, # bars, border: opacity (0-1)
             bar.f.col=NULL, # bars, filling: color
             bar.f.o=0, # bars, filling: opacity (0-1)
             inf.b.col="black", # inference band, border: color
             inf.lwd=0.1, # inference band, border: line width
             inf.b.o=1, # inference band, border: opacity (0-1)
             inf.f.col="black", # inference band, filling: color
             inf.f.o=0, # inference band, filling: opacity (0-1)
             bean.b.col="black", # bean border, color
             bean.lwd=0.6, # bean border, line width
             bean.lty=1, # bean border, line type (1: solid; 2:dashed; 3: dotted; ...)
             bean.b.o=0.3, # bean border, opacity (0-1)
             bean.f.col="gray", # bean filling, color
             bean.f.o=.1, # bean filling, opacity (0-1)
             cap.beans=TRUE, # max and min values of bean densities are capped at the limits found in the data
             # quant=c(.1,.9), # quantiles (e.g., 10th and 90th)
             # quant.col="black", # quantiles, line: color
             # quant.length=.7, # quantiles, horizontal line length
             # quant.lwd=2, # quantiles, line width
             gl.col="gray", # gridlines: color
             gl.lwd=c(.75,0), # gridlines: line width
             gl.lty=2, # gridlines: line type (1: solid; 2:dashed; 3: dotted; ...)
             cex.lab=0.8, # axis labels: size
             cex.axis=1, # axis numbers: size
             bty="l", # plot box type
             back.col="white") # background, color
```

\newpage

### Statistics 

```{r, warning=FALSE, message=FALSE}
# Set the working directory in order to load the models
# Set working directory
setwd("C:/Users/igrahek/Documents/Studies/SSVEP Reward - Soren & Antonio/Experiment 1/SSVEP and reward/brms_models")

# # referencing for easier interpretation
# data.final$ExpPhase=relevel(data.final$ExpPhase,ref="Bsln")
# data.final$Condition=relevel(data.final$Condition,ref="High_Rew")
# 
# 
# # Null model
# model.null.Acc = brm(Hit.Rate ~ 1 + (1|ParticipantNo),
#                  data=data.final,
#                  family=gaussian(),
#                  warmup = 2000,
#                  iter = 10000,
#                  save_all_pars = TRUE,
#                  control = list(adapt_delta = 0.99),
#                  cores = 4,
#                  sample_prior = TRUE)
# saveRDS(model.null.Acc,file="nullmodel.Acc.rds")
# 
# # ExpPhase model
# model.expphase.Acc = brm(Hit.Rate ~ ExpPhase + (ExpPhase|ParticipantNo),
#                      data=data.final,
#                      family=gaussian(),
#                      warmup = 2000,
#                      iter = 10000,
#                      save_all_pars = TRUE,
#                      control = list(adapt_delta = 0.99),
#                      cores = 4,
#                      sample_prior = TRUE)
# saveRDS(model.expphase.Acc,file="expphasemodel.Acc.rds")
# 
# #Interaction model
# model.full.Acc = brm(Hit.Rate ~ ExpPhase * Condition + (ExpPhase * Condition|ParticipantNo),
#                  data=data.final,
#                  family=gaussian(),
#                  warmup = 2000,
#                  iter = 10000,
#                  save_all_pars = TRUE,
#                  control = list(adapt_delta = 0.99),
#                  cores = 4,
#                  sample_prior = TRUE)
# saveRDS(model.full.Acc,file="model.full.Acc.rds")

#WAIC
# compare.Acc.waic = WAIC(model.null.Acc,model.expphase.Acc,model.full.Acc, compare = TRUE)
# saveRDS(compare.Acc.waic,file="compare.Acc.waic")

# Weighted waic
# compare.Acc.waic.weights = model_weights(model.null.Acc,model.expphase.Acc,model.full.Acc, weights = "waic")
# saveRDS(compare.Acc.waic.weights,file="compare.Acc.waic.weights")

#read in the models and comparisons
# model.null.Acc = readRDS("nullmodel.Acc.rds")
# model.condition.Acc = readRDS("model.condition.Acc.rds")
# model.expphase.Acc = readRDS("expphasemodel.Acc.rds")
# model.twomaineffects.Acc = readRDS("model.twomaineffects.Acc.rds")
model.full.Acc = readRDS("model.full.Acc.rds")
compare.waic.Acc = readRDS("compare.Acc.waic")
compare.Acc.waic.weights = readRDS("compare.Acc.waic.weights")
bR2.null.Acc = readRDS("bR2.null.Acc")
bR2.expphase.Acc = readRDS("bR2.expphase.Acc")
bR2.full.Acc = readRDS("bR2.full.Acc")
```

### Model comparison with WAIC

```{r, warning=FALSE, message=FALSE}
print(compare.waic.Acc)
```

### Model comparison with WAIC weights

```{r, warning=FALSE, message=FALSE}
print(compare.Acc.waic.weights)
```

### Bayesian R squared 

Null model
```{r, warning=FALSE, message=FALSE}
print(bR2.null.Acc)
```

Experiment phase model
```{r, warning=FALSE, message=FALSE}
print(bR2.expphase.Acc)
```

Full model
```{r, warning=FALSE, message=FALSE}
print(bR2.full.Acc)
```

### Checking the best model

Plotting the chains
```{r, warning=FALSE, message=FALSE}
# Plot chains
plot(model.full.Acc, pars = "^b_", ask = FALSE, N=6)
```

Summary of the best model 

```{r, warning=FALSE, message=FALSE}
# Summary of the best model
print(tidy(model.full.Acc, par_type = "non-varying"), digits = 1)
```

### Plotting the best model

```{r, warning=FALSE, message=FALSE}
# Plot the interaction between Phase and Attention in two conditions of reward probability
# conditions = data.frame(Condition = c("High_Rew", "Low_Rew"))
plot(marginal_effects(model.full.Acc, effects = "ExpPhase:Condition"),ask=FALSE)
```

### Inference about the best model

#### Sample from the posterior
```{r, warning=FALSE, message=FALSE}
# Analyzing the posterior and differences between conditions

post = posterior_samples(model.full.Acc, "^b")


################################################ Baseline ####

######### High reward
Baseline_High = post[["b_Intercept"]]
######### Low reward
Baseline_Low = post[["b_Intercept"]] + 
  post[["b_ConditionLow_Rew"]] 

################################################ Acquistion

######### High reward
Acquisition_High = post[["b_Intercept"]] + 
  post[["b_ExpPhaseAcq"]] 
######### Low reward
Acquisition_Low = post[["b_Intercept"]] + 
  post[["b_ExpPhaseAcq"]] + 
  post[["b_ConditionLow_Rew"]] + 
  post[["b_ExpPhaseAcq:ConditionLow_Rew"]]

################################################ Extinction

######### High reward
Extinction_High = post[["b_Intercept"]] + 
  post[["b_ExpPhaseExt"]] 
######### Low reward
Extinction_Low = post[["b_Intercept"]] + 
  post[["b_ExpPhaseExt"]] + 
  post[["b_ConditionLow_Rew"]] + 
  post[["b_ExpPhaseExt:ConditionLow_Rew"]]
```

```{r, warning=FALSE, message=FALSE}

# make a data frame
posterior_conditions = melt(data.frame(Baseline_High, Baseline_Low, Acquisition_High, Acquisition_Low, Extinction_High, Extinction_Low))

posterior_conditions =  posterior_conditions %>% separate(variable, c("Reward_Phase", "Reward_Magnitude"), "_", extra = "merge")

names(posterior_conditions)[3] = "Hit_rate"



# Pirate plot
pirateplot(formula=Hit_rate ~ Reward_Phase + Reward_Magnitude, # dependent~independent variables
           data=posterior_conditions, # data frame
           main="Hit rates", # main title
           xlim=NULL, # x-axis: limits
           xlab="", # x-axis: label
           ylim=c(0.5, 0.7), # y-axis: limits
           ylab="Hit rate", # y-axis: label
           inf.method="sd", # type of inference: 95% Bayesian Highest Density Intervals
           #hdi.iter=5000, # number of iterations for estimation of HDI
           #inf.within=ParticipantNo, # ID variable
           theme=0, # preset theme (0: use your own)
           # theme settings
           # pal="xman", # color palette [see piratepal(palette="all")]
           #point.col="black", # points: color
           #point.o=.3, # points: opacity (0-1)
           avg.line.col="black", # average line: color
           avg.line.lwd=2, # average line: line width
           avg.line.o=1, # average line: opacity (0-1)
           bar.b.col=NULL, # bars, border: color
           bar.lwd=0, # bars, border: line width
           bar.b.o=0, # bars, border: opacity (0-1)
           bar.f.col=NULL, # bars, filling: color
           bar.f.o=0, # bars, filling: opacity (0-1)
           inf.b.col="black", # inference band, border: color
           inf.lwd=0.1, # inference band, border: line width
           inf.b.o=1, # inference band, border: opacity (0-1)
           inf.f.col="black", # inference band, filling: color
           inf.f.o=0, # inference band, filling: opacity (0-1)
           bean.b.col="black", # bean border, color
           bean.lwd=0.6, # bean border, line width
           bean.lty=1, # bean border, line type (1: solid; 2:dashed; 3: dotted; ...)
           bean.b.o=0.3, # bean border, opacity (0-1)
           bean.f.col="gray", # bean filling, color
           bean.f.o=.1, # bean filling, opacity (0-1)
           cap.beans=TRUE, # max and min values of bean densities are capped at the limits found in the data
           sortx = "sequential", # how to sort the x axis
           # quant=c(.1,.9), # quantiles (e.g., 10th and 90th)
           # quant.col="black", # quantiles, line: color
           # quant.length=.7, # quantiles, horizontal line length
           # quant.lwd=2, # quantiles, line width
           gl.col="gray", # gridlines: color
           gl.lwd=c(.75,0), # gridlines: line width
           gl.lty=2, # gridlines: line type (1: solid; 2:dashed; 3: dotted; ...)
           cex.lab=1, # axis labels: size
           cex.axis=1, # axis numbers: size
           bty="l", # plot box type
           back.col="white") # background, color
```

Table of means across conditions

```{r, warning=FALSE, message=FALSE}
library(HDInterval)

# Make a table with conditions
posterior_means = as.data.frame(c("Baseline High Reward", 
                                  "Baseline Low Reward", 
                                  "Acquisition High Reward", 
                                  "Acquisition Low Reward", 
                                  "Extinction High Reward", 
                                  "Extinction Low Reward"))
names(posterior_means)[1] = "Condition"

posterior_means$Mean = c(paste(round(mean(Baseline_High), digits = 2), " [", round(hdi(Baseline_High)[[1]], digits = 2), " ", round(hdi(Baseline_High)[[2]], digits = 2), "]"),
                        paste(round(mean(Baseline_Low), digits = 2), " [", round(hdi(Baseline_Low)[[1]], digits = 2), " ", round(hdi(Baseline_Low)[[2]], digits = 2), "]"),
                        paste(round(mean(Acquisition_High), digits = 2), " [", round(hdi(Acquisition_High)[[1]], digits = 2), " ", round(hdi(Acquisition_High)[[2]], digits = 2), "]"),
                        paste(round(mean(Acquisition_Low), digits = 2), " [", round(hdi(Acquisition_Low)[[1]], digits = 2), " ", round(hdi(Acquisition_Low)[[2]], digits = 2), "]"),
                        paste(round(mean(Extinction_High), digits = 2), " [", round(hdi(Extinction_High)[[1]], digits = 2), " ", round(hdi(Extinction_High)[[2]], digits = 2), "]"),
                        paste(round(mean(Extinction_Low), digits = 2), " [", round(hdi(Extinction_Low)[[1]], digits = 2), " ", round(hdi(Extinction_Low)[[2]], digits = 2), "]"))

names(posterior_means)[2] = "Mean [HDI]"
                        
print(posterior_means)
```


Check the difference between high reward in baseline vs. acquisition 

```{r, warning=FALSE, message=FALSE}
Diff_Bsln_Acq_High = Acquisition_High - Baseline_High
plotPost(Diff_Bsln_Acq_High, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('Mean = ', round(mean(Diff_Bsln_Acq_High), digits = 2))
cat('SD = ', round(sd(Diff_Bsln_Acq_High), digits = 2))
cat('SE = ', round(sd(Diff_Bsln_Acq_High/sqrt(length(Diff_Bsln_Acq_High))), digits = 2))
```

Check the difference between low reward in baseline vs. acquisition 

```{r, warning=FALSE, message=FALSE}
Diff_Bsln_Acq_Low = Acquisition_Low - Baseline_Low
plotPost(Diff_Bsln_Acq_Low, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('Mean = ', round(mean(Diff_Bsln_Acq_Low), digits = 2))
cat('SD = ', round(sd(Diff_Bsln_Acq_Low), digits = 2))
cat('SE = ', round(sd(Diff_Bsln_Acq_Low/sqrt(length(Diff_Bsln_Acq_Low))), digits = 2))
```

Difference between the upper two
```{r, warning=FALSE, message=FALSE}
Diff_Diff = Diff_Bsln_Acq_Low - Diff_Bsln_Acq_High
plotPost(Diff_Diff, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
```

Check the difference between high reward in acquisition vs. extinction 

```{r, warning=FALSE, message=FALSE}
Diff_Acq_Ext_High = Extinction_High - Acquisition_High
plotPost(Diff_Acq_Ext_High, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('Mean = ', round(mean(Diff_Acq_Ext_High), digits = 2))
cat('SD = ', round(sd(Diff_Acq_Ext_High), digits = 2))
cat('SE = ', round(sd(Diff_Acq_Ext_High/sqrt(length(Diff_Acq_Ext_High))), digits = 2))
```

Check the difference between low reward in acquisition vs. extinction 

```{r, warning=FALSE, message=FALSE}
Diff_Acq_Ext_Low = Extinction_Low - Acquisition_Low
plotPost(Diff_Acq_Ext_Low, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('Mean = ', round(mean(Diff_Acq_Ext_Low), digits = 2))
cat('SD = ', round(sd(Diff_Acq_Ext_Low), digits = 2))
cat('SE = ', round(sd(Diff_Acq_Ext_Low/sqrt(length(Diff_Acq_Ext_Low))), digits = 2))
```

## Reaction times

### Plot

```{r, warning=FALSE, message=FALSE}
# Pirate plot

recode  

pirateplot(formula=Hits.RTs~ExpPhase+Condition, # dependent~independent variables
             data=data.final, # data frame
             main="Reaction times", # main title
             xlim=NULL, # x-axis: limits
             xlab="", # x-axis: label
             ylim=c(400,700), # y-axis: limits
             ylab="Reaction time", # y-axis: label
             inf.method="hdi", # type of inference: 95% Bayesian Highest Density Intervals
             hdi.iter=5000, # number of iterations for estimation of HDI
             inf.within=ParticipantNo, # ID variable
             theme=0, # preset theme (0: use your own)
             # theme settings
             # pal="xman", # color palette [see piratepal(palette="all")]
             point.col="black", # points: color
             point.o=.3, # points: opacity (0-1)
             avg.line.col="black", # average line: color
             avg.line.lwd=2, # average line: line width
             avg.line.o=1, # average line: opacity (0-1)
             bar.b.col=NULL, # bars, border: color
             bar.lwd=0, # bars, border: line width
             bar.b.o=0, # bars, border: opacity (0-1)
             bar.f.col=NULL, # bars, filling: color
             bar.f.o=0, # bars, filling: opacity (0-1)
             inf.b.col="black", # inference band, border: color
             inf.lwd=0.1, # inference band, border: line width
             inf.b.o=1, # inference band, border: opacity (0-1)
             inf.f.col="black", # inference band, filling: color
             inf.f.o=0, # inference band, filling: opacity (0-1)
             bean.b.col="black", # bean border, color
             bean.lwd=0.6, # bean border, line width
             bean.lty=1, # bean border, line type (1: solid; 2:dashed; 3: dotted; ...)
             bean.b.o=0.3, # bean border, opacity (0-1)
             bean.f.col="gray", # bean filling, color
             bean.f.o=.1, # bean filling, opacity (0-1)
             cap.beans=TRUE, # max and min values of bean densities are capped at the limits found in the data
             # quant=c(.1,.9), # quantiles (e.g., 10th and 90th)
             # quant.col="black", # quantiles, line: color
             # quant.length=.7, # quantiles, horizontal line length
             # quant.lwd=2, # quantiles, line width
             gl.col="gray", # gridlines: color
             gl.lwd=c(.75,0), # gridlines: line width
             gl.lty=2, # gridlines: line type (1: solid; 2:dashed; 3: dotted; ...)
             cex.lab=0.8, # axis labels: size
             cex.axis=1, # axis numbers: size
             bty="l", # plot box type
             back.col="white") # background, color
```

### Statistics
```{r, warning=FALSE, message=FALSE}
# Set the working directory in order to load the models
# Set working directory
setwd("C:/Users/igrahek/Documents/Studies/SSVEP Reward - Soren & Antonio/Experiment 1/SSVEP and reward/brms_models")
# 
# referencing for easier interpretation
# data.final$ExpPhase=relevel(data.final$ExpPhase,ref="Bsln")
# data.final$Condition=relevel(data.final$Condition,ref="High_Rew")
# 
# # Null model
# model.null.RT = brm(Hits.RTs ~ 1 + (1|ParticipantNo),
#                  data=data.final,
#                  family=gaussian(),
#                  warmup = 2000,
#                  iter = 10000,
#                  save_all_pars = TRUE,
#                  control = list(adapt_delta = 0.99),
#                  cores = 4,
#                  sample_prior = TRUE)
# saveRDS(model.null.RT,file="nullmodel.RT.rds")
# 
# # ExpPhase model
# model.expphase.RT = brm(Hits.RTs ~ ExpPhase + (ExpPhase|ParticipantNo),
#                  data=data.final,
#                  family=gaussian(),
#                  warmup = 2000,
#                  iter = 10000,
#                  save_all_pars = TRUE,
#                  control = list(adapt_delta = 0.99),
#                  cores = 4,
#                  sample_prior = TRUE)
# saveRDS(model.expphase.RT,file="expphasemodel.RT.rds")
# 
# #Interaction model
# model.full.RT = brm(Hits.RTs ~ ExpPhase * Condition + (ExpPhase * Condition|ParticipantNo),
#                  data=data.final,
#                  family=gaussian(),
#                  warmup = 2000,
#                  iter = 10000,
#                  save_all_pars = TRUE,
#                  control = list(adapt_delta = 0.99),
#                  cores = 4,
#                  sample_prior = TRUE)
# saveRDS(model.full.RT,file="model.full.RT.rds")
# 
# #WAIC
# compare.RT.waic = WAIC(model.null.RT,model.expphase.RT,model.full.RT, comapre = TRUE)
# saveRDS(compare.RT.waic,file="compare.RT.waic")
# 
# # Weighted waic
# compare.RT.waic.weights = model_weights(model.null.RT,model.expphase.RT,model.full.RT, weights = "waic")
# saveRDS(compare.RT.waic.weights,file="compare.RT.waic.weights")
# 
# # Bayesian R2
# #Null
# bR2.null.RT = bayes_R2(model.null.RT)
# saveRDS(bR2.null.RT,file="bR2.null.RT")
# #ExpPhase
# bR2.expphase.RT = bayes_R2(model.expphase.RT)
# saveRDS(bR2.expphase.RT,file="bR2.expphase.RT")
# #Full
# bR2.full.RT = bayes_R2(model.full.RT)
# saveRDS(bR2.full.RT,file="bR2.full.RT")

# # read in the models and comparisons

# model.null.RT = readRDS("nullmodel.RT.rds")
# model.expphase.RT = readRDS("expphasemodel.RT.rds")
model.full.RT = readRDS("model.full.RT.rds")
compare.waic.RT = readRDS("compare.RT.waic")
compare.RT.waic.weights = readRDS("compare.RT.waic.weights")
bR2.null.RT = readRDS("bR2.null.RT")
bR2.expphase.RT = readRDS("bR2.expphase.RT")
bR2.full.RT = readRDS("bR2.full.RT")
```

### Model comparison with WAIC

```{r, warning=FALSE, message=FALSE}
print(compare.waic.RT)
```

### Model comparison with WAIC weights

```{r, warning=FALSE, message=FALSE}
print(compare.RT.waic.weights)
```

### Bayesian R squared 

Null model
```{r, warning=FALSE, message=FALSE}
print(bR2.null.RT)
```

Experiment phase model
```{r, warning=FALSE, message=FALSE}
print(bR2.expphase.RT)
```

Full model
```{r, warning=FALSE, message=FALSE}
print(bR2.full.RT)
```

### Checking the best model

Plotting the chains
```{r, warning=FALSE, message=FALSE}
# Plot chains
plot(model.full.RT, pars = "^b_", ask = FALSE, N=6)
```

Summary of the best model 

```{r, warning=FALSE, message=FALSE}
# Summary of the best model
print(tidy(model.full.RT, par_type = "non-varying"), digits = 1)
```


### Plotting the best model

```{r, warning=FALSE, message=FALSE}
# Plot the interaction between Phase and Attention in two conditions of reward probability
# conditions = data.frame(Condition = c("High_Rew", "Low_Rew"))
plot(marginal_effects(model.full.RT, effects = "ExpPhase:Condition"),ask=FALSE)
```

### Inference about the best model

#### Sample from the posterior
```{r, warning=FALSE, message=FALSE}

# Analyzing the posterior and differences between conditions

post = posterior_samples(model.full.RT, "^b")


################################################ Baseline ####

######### High reward
Baseline_High = post[["b_Intercept"]]
######### Low reward
Baseline_Low = post[["b_Intercept"]] + 
  post[["b_ConditionLow_Rew"]] 

################################################ Acquistion

######### High reward
Acquisition_High = post[["b_Intercept"]] + 
  post[["b_ExpPhaseAcq"]] 
######### Low reward
Acquisition_Low = post[["b_Intercept"]] + 
  post[["b_ExpPhaseAcq"]] + 
  post[["b_ConditionLow_Rew"]] + 
  post[["b_ExpPhaseAcq:ConditionLow_Rew"]]

################################################ Extinction

######### High reward
Extinction_High = post[["b_Intercept"]] + 
  post[["b_ExpPhaseExt"]] 
######### Low reward
Extinction_Low = post[["b_Intercept"]] + 
  post[["b_ExpPhaseExt"]] + 
  post[["b_ConditionLow_Rew"]] + 
  post[["b_ExpPhaseExt:ConditionLow_Rew"]]
```

```{r, warning=FALSE, message=FALSE}
# make a data frame
posterior_conditions = melt(data.frame(Baseline_High, Baseline_Low, Acquisition_High, Acquisition_Low, Extinction_High, Extinction_Low))

posterior_conditions =  posterior_conditions %>% separate(variable, c("Reward_Phase", "Reward_Magnitude"), "_", extra = "merge")

names(posterior_conditions)[3] = "Reaction_time"



# Pirate plot
pirateplot(formula=Reaction_time ~ Reward_Phase + Reward_Magnitude, # dependent~independent variables
           data=posterior_conditions, # data frame
           main="Reaction times", # main title
           xlim=NULL, # x-axis: limits
           xlab="", # x-axis: label
           ylim=c(485,600), # y-axis: limits
           ylab="Reaction time", # y-axis: label
           inf.method="sd", # type of inference: 95% Bayesian Highest Density Intervals
           #hdi.iter=5000, # number of iterations for estimation of HDI
           #inf.within=ParticipantNo, # ID variable
           theme=0, # preset theme (0: use your own)
           # theme settings
           # pal="xman", # color palette [see piratepal(palette="all")]
           #point.col="black", # points: color
           #point.o=.3, # points: opacity (0-1)
           avg.line.col="black", # average line: color
           avg.line.lwd=2, # average line: line width
           avg.line.o=1, # average line: opacity (0-1)
           bar.b.col=NULL, # bars, border: color
           bar.lwd=0, # bars, border: line width
           bar.b.o=0, # bars, border: opacity (0-1)
           bar.f.col=NULL, # bars, filling: color
           bar.f.o=0, # bars, filling: opacity (0-1)
           inf.b.col="black", # inference band, border: color
           inf.lwd=0.1, # inference band, border: line width
           inf.b.o=1, # inference band, border: opacity (0-1)
           inf.f.col="black", # inference band, filling: color
           inf.f.o=0, # inference band, filling: opacity (0-1)
           bean.b.col="black", # bean border, color
           bean.lwd=0.6, # bean border, line width
           bean.lty=1, # bean border, line type (1: solid; 2:dashed; 3: dotted; ...)
           bean.b.o=0.3, # bean border, opacity (0-1)
           bean.f.col="gray", # bean filling, color
           bean.f.o=.1, # bean filling, opacity (0-1)
           cap.beans=TRUE, # max and min values of bean densities are capped at the limits found in the data
           sortx = "sequential", # how to sort the x axis
           # quant=c(.1,.9), # quantiles (e.g., 10th and 90th)
           # quant.col="black", # quantiles, line: color
           # quant.length=.7, # quantiles, horizontal line length
           # quant.lwd=2, # quantiles, line width
           gl.col="gray", # gridlines: color
           gl.lwd=c(.75,0), # gridlines: line width
           gl.lty=2, # gridlines: line type (1: solid; 2:dashed; 3: dotted; ...)
           cex.lab=1, # axis labels: size
           cex.axis=1, # axis numbers: size
           bty="l", # plot box type
           back.col="white") # background, color
```


Table of means across conditions

```{r, warning=FALSE, message=FALSE}
library(HDInterval)

# Make a table with conditions
posterior_means = as.data.frame(c("Baseline High Reward", 
                                  "Baseline Low Reward", 
                                  "Acquisition High Reward", 
                                  "Acquisition Low Reward", 
                                  "Extinction High Reward", 
                                  "Extinction Low Reward"))
names(posterior_means)[1] = "Condition"

posterior_means$Mean = c(paste(round(mean(Baseline_High), digits = 2), " [", round(hdi(Baseline_High)[[1]], digits = 2), " ", round(hdi(Baseline_High)[[2]], digits = 2), "]"),
                        paste(round(mean(Baseline_Low), digits = 2), " [", round(hdi(Baseline_Low)[[1]], digits = 2), " ", round(hdi(Baseline_Low)[[2]], digits = 2), "]"),
                        paste(round(mean(Acquisition_High), digits = 2), " [", round(hdi(Acquisition_High)[[1]], digits = 2), " ", round(hdi(Acquisition_High)[[2]], digits = 2), "]"),
                        paste(round(mean(Acquisition_Low), digits = 2), " [", round(hdi(Acquisition_Low)[[1]], digits = 2), " ", round(hdi(Acquisition_Low)[[2]], digits = 2), "]"),
                        paste(round(mean(Extinction_High), digits = 2), " [", round(hdi(Extinction_High)[[1]], digits = 2), " ", round(hdi(Extinction_High)[[2]], digits = 2), "]"),
                        paste(round(mean(Extinction_Low), digits = 2), " [", round(hdi(Extinction_Low)[[1]], digits = 2), " ", round(hdi(Extinction_Low)[[2]], digits = 2), "]"))

names(posterior_means)[2] = "Mean [HDI]"
                        
print(posterior_means)
```

Check the difference between high reward in baseline vs. acquisition 

```{r, warning=FALSE, message=FALSE}
Diff_Bsln_Acq_High = Acquisition_High - Baseline_High
plotPost(Diff_Bsln_Acq_High, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('HDI = ', round(hdi(Diff_Bsln_Acq_High),digits = 2))
cat('Mean = ', round(mean(Diff_Bsln_Acq_High), digits = 2))
cat('SD = ', round(sd(Diff_Bsln_Acq_High), digits = 2))
cat('SE = ', round(sd(Diff_Bsln_Acq_High/sqrt(length(Diff_Bsln_Acq_High))), digits = 2))
```

Check the difference between low reward in baseline vs. acquisition 

```{r, warning=FALSE, message=FALSE}
Diff_Bsln_Acq_Low = Acquisition_Low - Baseline_Low 
plotPost(Diff_Bsln_Acq_Low, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('HDI = ', round(hdi(Diff_Bsln_Acq_Low),digits = 2))
cat('Mean = ', round(mean(Diff_Bsln_Acq_Low), digits = 2))
cat('SD = ', round(sd(Diff_Bsln_Acq_Low), digits = 2))
cat('SE = ', round(sd(Diff_Bsln_Acq_Low/sqrt(length(Diff_Bsln_Acq_Low))), digits = 2))
```

Check the difference between high reward in acquisition vs. extinction 

```{r, warning=FALSE, message=FALSE}
Diff_Acq_Ext_High = Extinction_High - Acquisition_High
plotPost(Diff_Acq_Ext_High, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('HDI = ', round(hdi(Diff_Acq_Ext_High),digits = 2))
cat('Mean = ', round(mean(Diff_Acq_Ext_High), digits = 2))
cat('SD = ', round(sd(Diff_Acq_Ext_High), digits = 2))
cat('SE = ', round(sd(Diff_Acq_Ext_High/sqrt(length(Diff_Acq_Ext_High))), digits = 2))
```

Check the difference between low reward in acquisition vs. extinction 

```{r, warning=FALSE, message=FALSE}
Diff_Acq_Ext_Low = Extinction_Low - Acquisition_Low
plotPost(Diff_Acq_Ext_Low, xlab = "", col = "#b3cde0", showCurve = FALSE, cex = 1, compVal = 0)
cat('HDI = ', round(hdi(Diff_Acq_Ext_Low),digits = 2))
cat('Mean = ', round(mean(Diff_Acq_Ext_Low), digits = 2))
cat('SD = ', round(sd(Diff_Acq_Ext_Low), digits = 2))
cat('SE = ', round(sd(Diff_Acq_Ext_Low/sqrt(length(Diff_Acq_Ext_Low))), digits = 2))
```